cpp_warmups = {
    "Основы C++": [
        {
            "question": "Что означает оператор 'new' в C++?",
            "options": [
                "Выделение памяти в стеке",
                "Выделение динамической памяти в куче",
                "Создание ссылки на объект",
                "Инициализация константы"
            ],
            "correct": 1,
            "explanation": "Оператор 'new' выделяет память в динамической памяти (куче) и возвращает указатель на эту память"
        },
        {
            "question": "Как правильно освободить память, выделенную с помощью 'new'?",
            "options": [
                "Использовать delete",
                "Использовать free()",
                "Использовать remove()",
                "Память освобождается автоматически"
            ],
            "correct": 0,
            "explanation": "Для освобождения памяти, выделенной с помощью 'new', используется оператор 'delete'"
        },
        {
            "question": "Что такое RAII в C++?",
            "options": [
                "Random Access Input Interface",
                "Resource Acquisition Is Initialization",
                "Runtime Array Index Initializer",
                "Recursive Algorithm Implementation Interface"
            ],
            "correct": 1,
            "explanation": "RAII (Resource Acquisition Is Initialization) - идиома, при которой выделение ресурса происходит в конструкторе, а освобождение - в деструкторе"
        },
        {
            "question": "Что такое шаблоны (templates) в C++?",
            "options": [
                "Способ создания абстрактных классов",
                "Механизм для создания обобщенных функций и классов",
                "Способ скрытия реализации",
                "Тип умных указателей"
            ],
            "correct": 1,
            "explanation": "Шаблоны позволяют создавать функции и классы, которые работают с разными типами данных"
        },
        {
            "question": "Что такое конструктор копирования?",
            "options": [
                "Конструктор, который копирует только указатели",
                "Конструктор, который создает глубокую копию объекта",
                "Конструктор, который инициализирует все поля нулями",
                "Конструктор по умолчанию"
            ],
            "correct": 1,
            "explanation": "Конструктор копирования создает новый объект как копию существующего объекта"
        }
    ],
    
    "STL (Standard Template Library)": [
        {
            "question": "Какой контейнер STL обеспечивает быстрый произвольный доступ к элементам?",
            "options": [
                "std::list",
                "std::vector",
                "std::map",
                "std::set"
            ],
            "correct": 1,
            "explanation": "std::vector обеспечивает произвольный доступ к элементам за O(1) с помощью оператора []"
        },
        {
            "question": "Какой алгоритм используется для сортировки в STL?",
            "options": [
                "std::binary_search",
                "std::find",
                "std::sort",
                "std::transform"
            ],
            "correct": 2,
            "explanation": "std::sort - алгоритм сортировки в STL, обычно реализует быструю сортировку"
        },
        {
            "question": "Какой контейнер хранит уникальные элементы в отсортированном порядке?",
            "options": [
                "std::unordered_set",
                "std::multiset",
                "std::set",
                "std::vector"
            ],
            "correct": 2,
            "explanation": "std::set хранит уникальные элементы в отсортированном порядке"
        },
        {
            "question": "Что такое итератор в STL?",
            "options": [
                "Объект для инициализации контейнеров",
                "Объект, который предоставляет доступ к элементам контейнера",
                "Функция для сравнения элементов",
                "Тип данных для хранения индексов"
            ],
            "correct": 1,
            "explanation": "Итератор - это объект, который позволяет перебирать элементы контейнера и получать к ним доступ"
        },
        {
            "question": "Какой контейнер реализует ассоциативный массив?",
            "options": [
                "std::vector",
                "std::list",
                "std::map",
                "std::stack"
            ],
            "correct": 2,
            "explanation": "std::map - это ассоциативный контейнер, который хранит пары ключ-значение"
        }
    ],
    
    "Указатели и память": [
        {
            "question": "Что такое умный указатель (smart pointer) в C++11?",
            "options": [
                "Указатель, который автоматически увеличивается",
                "Указатель с проверкой границ",
                "Класс, который автоматически управляет памятью",
                "Указатель только для чтения"
            ],
            "correct": 2,
            "explanation": "Умные указатели (unique_ptr, shared_ptr, weak_ptr) - это классы, которые автоматически управляют памятью"
        },
        {
            "question": "В чем разница между delete и delete[]?",
            "options": [
                "delete освобождает массив, delete[] - один элемент",
                "delete[] освобождает массив, delete - один элемент",
                "Нет разницы",
                "delete[] используется только для указателей на указатели"
            ],
            "correct": 1,
            "explanation": "delete освобождает память для одного объекта, delete[] - для массива объектов"
        },
        {
            "question": "Что такое виртуальная функция?",
            "options": [
                "Функция, которая не имеет реализации",
                "Функция, которая может быть переопределена в производных классах",
                "Функция, которая работает с виртуальной памятью",
                "Функция-шаблон"
            ],
            "correct": 1,
            "explanation": "Виртуальная функция может быть переопределена в производных классах, обеспечивая полиморфизм"
        }
    ]
}